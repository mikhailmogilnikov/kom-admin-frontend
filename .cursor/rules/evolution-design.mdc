---
alwaysApply: false
applyIntelligently: |
  Apply this rule when:
  - Creating or refactoring features/ modules and their structure
  - Creating or refactoring services/ modules
  - Organizing shared/ components, utilities, or types
  - Setting up module structure (choosing between Single File, Flat, Grouped, or Compose patterns)
  - Setting up direct imports from specific files (avoiding barrel files)
  - Checking import dependencies between layers (app → features → services → shared)
  - Composing features together in app/ layer
  - Deciding where to place new code (which layer and module)
  - Resolving circular dependencies or cross-layer imports
  - Migrating existing code to ED architecture
  - Creating new UI components (deciding between shared/ui vs feature-specific)
  - Setting up API clients or business logic (services vs features)
  - Organizing complex modules with submodules or compose patterns

  Do NOT apply when:
  - Working with configuration files (vite.config, tsconfig, etc.)
  - Setting up development tools or build scripts
  - Writing unit tests or test utilities
  - Working with third-party library integrations that don't fit the architecture
  - Making small fixes to existing code that already follows the pattern
  - Working with route definitions in routes/ (handled by router architecture)
---

# Evolution Design (ED) Architecture

The project uses **Evolution Design (ED Small)** architecture for organizing frontend code.

## Core Principles

### Layered Architecture

Code is organized into 4 main layers with **unidirectional dependencies** (imports only go down):

```
app/ ─────┐
          ↓
features/ ┼─────┐
          ↓     ↓
services/ ──────┼─────┐
                ↓     ↓
shared/   ──────┴─────┘
```

### 1. `app/` Layer

**Purpose:** Application entry point, global configuration, features composition

**May contain:**

- `main.tsx` - application entry point
- `app.tsx` - root component
- `router.tsx` - routing configuration
- `providers.tsx` - global providers
- `global.css` - global styles
- Composition of features into a single application

**Rules:**

- Most frequently changing logic
- Can import from all layers
- Structure is not standardized
- Minimum business logic

**Examples:**

```tsx
// ✅ Good: features composition with direct imports
import { AuthProvider } from "@/features/auth/ui/auth-provider";
import { TaskList } from "@/features/task-list/ui/task-list";

export function App() {
  return (
    <AuthProvider>
      <TaskList />
    </AuthProvider>
  );
}

// ❌ Bad: business logic in app
export function App() {
  const [tasks, setTasks] = useState([]);
  // task management logic should be in features
}
```

### 2. `features/` Layer

**Purpose:** Large independent pieces of application functionality

**Module structure:**

```
features/
  ├── auth/              # feature module
  ├── task-list/         # feature module
  └── user-profile/      # feature module
```

**Rules:**

- Each folder = **large independent feature**
- Features do NOT depend on each other directly
- Most of the application code should be here
- Can import: `services/`, `shared/`
- CANNOT import: other `features/`, `app/`

**Tip:** Don't make features too small! It's normal to have 3-4 features at the start.

**Examples:**

```tsx
// ✅ Good: independent feature
// features/task-list/task-list.tsx
import { useTaskApi } from "@/services/tasks";
import { Button } from "@/shared/ui/button";

export function TaskList() {
  const { tasks } = useTaskApi();
  return <div>{/* ... */}</div>;
}

// ❌ Bad: dependency between features
// features/task-list/task-list.tsx
import { UserProfile } from "@/features/user-profile"; // ❌
```

### 3. `services/` Layer

**Purpose:** Reusable business logic not tied to a specific feature

**May contain:**

- API clients
- Business logic used across different features
- External services integration
- Stores (if using state management)

**Rules:**

- Services do NOT depend on each other
- Can import: `shared/`
- CANNOT import: `features/`, `app/`, other `services/`

**Examples:**

```tsx
// ✅ Good: reusable API
// services/tasks/api.ts
import { apiClient } from "@/shared/api/client";

export const tasksApi = {
  getAll: () => apiClient.get("/tasks"),
  create: (data) => apiClient.post("/tasks", data),
};

// ❌ Bad: dependency between services
// services/tasks/api.ts
import { userApi } from "@/services/user"; // ❌
```

### 4. `shared/` Layer

**Purpose:** Common reusable code

**May contain:**

- UI components (Button, Input, Card)
- Utilities (date formatting, validation)
- Hooks (useLocalStorage, useDebounce)
- Types and constants
- API client
- **Can contain business logic** (unlike FSD)

**Structure:**

```
shared/
  ├── ui/           # UI components
  ├── lib/          # utilities and helpers
  ├── api/          # base API client
  ├── types/        # common types
  └── config/       # configuration
```

**Rules:**

- CANNOT import anything from other layers
- Completely independent code

## Module Structure Evolution

### Stage 1: Single File Module

**When to use:** Module < 100 lines, all logic in one file

```
features/
  └── simple-feature.tsx
```

**Example:**

```tsx
// features/counter.tsx
import { useState } from "react";

export function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <span>{count}</span>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

### Stage 2: Flat Module

**When to use:** Module 100-300 lines, need file separation

```
features/
  └── todo-list/
      ├── api.ts          # API requests
      ├── todo-list.tsx   # main component
      ├── todo-item.tsx   # helper component
      └── use-todos.ts    # hooks
```

**Rules:**

- Export directly from files (no index.ts barrel file)
- Files at the same level can import each other
- Use direct imports from specific files

**Example:**

```tsx
// Import directly from specific files
import { TodoList } from "@/features/todo-list/todo-list";
import type { Todo } from "@/features/todo-list/types";
```

### Stage 3: Grouped Module

**When to use:** Module > 300 lines, many files with different purposes

```
features/
  └── todo-list/
      ├── api/
      │   └── todos-api.ts
      ├── ui/                 # UI components
      │   ├── todo-list.tsx
      │   ├── todo-item.tsx
      │   └── create-form.tsx
      ├── model/              # Logic and state
      │   ├── use-todos.ts
      │   └── use-create-todo.ts
      └── domain/             # Types and business logic
          └── todo.ts
```

**Standard groups:**

- `ui/` - components
- `model/` - hooks, stores, business logic
- `api/` - API requests
- `domain/` - types, constants, pure business logic
- `lib/` - module utilities
- `config/` - module configuration

**Rules:**

- Groups can import each other
- Export directly from specific files (no index.ts)
- Use direct imports from files within groups

**Example:**

```tsx
// Import directly from specific files in groups
import { TodoList } from "@/features/todo-list/ui/todo-list";
import { useTodos } from "@/features/todo-list/model/use-todos";
import type { Todo } from "@/features/todo-list/domain/todo";
```

### Stage 4: Module with Compose

**When to use:** Complex module with submodules and chaotic dependencies

```
features/
  └── todo-list/
      ├── api/
      │   └── todos-api.ts
      ├── compose/              # Mediators - connect parts
      │   ├── todo-list-page.tsx
      │   └── todo-details-page.tsx
      ├── domain/
      │   └── todo-item.ts
      ├── model/                # Independent hooks
      │   ├── use-todo-list.ts
      │   ├── use-create-todo.ts
      │   └── use-delete-todo.ts
      └── ui/                   # Independent components
          ├── todo-item.tsx
          ├── create-form.tsx
          └── fields/
              ├── text-field.tsx
              └── date-field.tsx
```

**Key principles:**

- `model/` and `ui/` do NOT depend on each other
- Connection happens in `compose/` through:
  - Slots and render-props for UI
  - Events and DI for model
- Files in `compose/` can import each other
- No index.ts files - import directly from specific files

**Example:**

```tsx
// compose/todo-list-page.tsx - mediator
import { useTodoList } from "../model/use-todo-list";
import { useCreateTodo } from "../model/use-create-todo";
import { useDeleteTodo } from "../model/use-delete-todo";
import { TodoItem } from "../ui/todo-item";
import { CreateForm } from "../ui/create-form";

export function TodoListPage() {
  const todoList = useTodoList();
  const createTodo = useCreateTodo();
  const deleteTodo = useDeleteTodo();

  return (
    <TodoPageLayout
      createForm={<CreateForm onCreate={createTodo} />}
      items={todoList.map((item) => (
        <TodoItem
          key={item.id}
          item={item}
          onDelete={() => deleteTodo(item.id)}
        />
      ))}
    />
  );
}
```

### Submodules

You can create nested modules:

```
features/
  └── todo-list/
      ├── api/
      │   └── todos-api.ts
      ├── todo-list/        # submodule
      │   └── ...
      └── todo-details/     # submodule
          └── ...
```

**Rules:**

- Submodules can import from parent module using relative paths
- Submodules should NOT import each other directly
- Connection through parent's compose
- No index.ts files - use direct imports

## Public API and Imports

**❌ AVOID barrel files (index.ts):**

Barrel files slow down performance and cause large module graphs. Instead, import directly from specific files.

**✅ Use direct imports:**

```tsx
// ✅ Good: direct import from specific file
import { LoginForm } from "@/features/auth/ui/login-form";
import { useAuth } from "@/features/auth/model/use-auth";
import type { User } from "@/features/auth/domain/user";

// ❌ Bad: using barrel file
import { LoginForm, useAuth, User } from "@/features/auth";
```

**File organization:**

- Each module should have clear structure with specific files
- Export what you need directly from files
- No index.ts re-exports needed
- Internal helpers, hooks, and utilities stay in their files

**Example structure:**

```
features/
  └── auth/
      ├── ui/
      │   ├── login-form.tsx    # export LoginForm component
      │   └── logout-button.tsx # export LogoutButton component
      ├── model/
      │   ├── use-auth.ts       # export useAuth hook
      │   └── auth-store.ts     # export authStore
      └── domain/
          └── user.ts           # export type User
```

## Import Rules

### ✅ Allowed:

```tsx
// app can import from any layer (direct imports)
import { TaskList } from "@/features/task-list/ui/task-list";
import { tasksApi } from "@/services/tasks/api/tasks-api";
import { Button } from "@/shared/ui/button";

// features can import services and shared (direct imports)
import { userApi } from "@/services/user/api/user-api";
import { formatDate } from "@/shared/lib/dates/format-date";

// services can import only shared (direct imports)
import { apiClient } from "@/shared/api/client";

// shared does not import other layers
```

### ❌ Forbidden:

```tsx
// features CANNOT import other features
import { UserProfile } from "@/features/user-profile/ui/profile"; // ❌

// features CANNOT import app
import { router } from "@/app/router"; // ❌

// services CANNOT import features
import { TaskList } from "@/features/task-list/ui/task-list"; // ❌

// services CANNOT import other services
import { userApi } from "@/services/user/api/user-api"; // ❌

// services CANNOT import app
import { config } from "@/app/config"; // ❌

// shared CANNOT import anything
import { useAuth } from "@/features/auth/model/use-auth"; // ❌

// DO NOT use barrel files (index.ts)
import { LoginForm } from "@/features/auth"; // ❌
```

## Feature Interaction

If features need to interact, use:

**1. Composition in app:**

```tsx
// app/app.tsx
import { Auth } from "@/features/auth/ui/auth";
import { TaskList } from "@/features/task-list/ui/task-list";

export function App() {
  return <Auth>{(user) => <TaskList userId={user.id} />}</Auth>;
}
```

**2. Shared service:**

```tsx
// services/user/model/user-store.ts
export const userStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
}));

// features/auth uses it (direct import)
import { userStore } from "@/services/user/model/user-store";

// features/task-list uses it (direct import)
import { userStore } from "@/services/user/model/user-store";
```

**3. Events through shared:**

```tsx
// shared/lib/events.ts
export const events = {
  userLoggedIn: createEvent<User>(),
};

// features/auth emits
import { events } from "@/shared/lib/events";
events.userLoggedIn.emit(user);

// features/notifications listens
import { events } from "@/shared/lib/events";
events.userLoggedIn.subscribe((user) => {
  showNotification(`Welcome ${user.name}`);
});
```

## Naming Recommendations

### Features:

- `auth` - authentication
- `task-list` - task list
- `user-profile` - user profile
- Use kebab-case
- Reflect functionality, not implementation

### Services:

- `api` - API client
- `tasks` - task operations
- `users` - user operations
- `storage` - storage operations

### Shared:

- `ui/` - interface components
- `lib/` - utilities
- `api/` - base API
- `types/` - types
- `config/` - configuration

## Checklist

When creating/modifying code, check:

- [ ] Code is in the correct layer
- [ ] Imports only go down through layers
- [ ] Features don't depend on each other
- [ ] Services don't depend on each other
- [ ] Using direct imports from specific files (no index.ts barrel files)
- [ ] Appropriate module structure chosen (stages 1-4)
- [ ] No business logic in app
- [ ] No circular dependencies

## Common Mistakes

### ❌ Small features

```
features/
  ├── button/          # too small
  ├── input/           # too small
  ├── form-field/      # too small
```

**✅ Correct:** This should be in `shared/ui/`

### ❌ Dependencies between features

```tsx
// features/task-list/ui/task-list.tsx
import { UserAvatar } from "@/features/user-profile/ui/avatar"; // ❌ Cross-feature import
```

**✅ Correct:**

- Move UserAvatar to `shared/ui/user-avatar.tsx`
- Or pass through props from `app`

```tsx
// After moving to shared
import { UserAvatar } from "@/shared/ui/user-avatar"; // ✅
```

### ❌ Too early transition to groups

```
features/
  └── simple-counter/    # 50 lines of code
      ├── index.ts
      ├── ui/
      │   └── counter.tsx
      ├── model/
      │   └── use-counter.ts
      └── domain/
          └── types.ts
```

**✅ Correct:** Use Flat Module or even Single File

## Migrating Existing Code

1. Identify current features in the application
2. Create folders in `features/`
3. Move code gradually, starting with the most independent parts
4. Extract common code to `shared/`
5. Create `services/` for reusable business logic
6. Simplify `app/` to composition only

## Useful Links

- [ED Documentation](https://ed.evocomm.space/guide/)
- [ED Small Guide](https://ed.evocomm.space/guide/ed-small/)
- [Deep Dive](https://ed.evocomm.space/deep-dive/)
